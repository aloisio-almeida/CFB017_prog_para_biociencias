# -*- coding: utf-8 -*-
"""classe_proteina.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1U43Ydo70DbCF4KH5YUHe_N8ZXB16KE_n
"""

'''Primeiramente precisamos criar a classe Proteina. Iremos utilizar "__init__" como o inicializador ou
construtor dessa Classe, pois o mesmo tem a capacidade de "inicializar" os atributos de uma classe.'''

class Proteina:
    def __init__(self, id, especie, peso_molecular, comprimento):
        self.id = id #Onde 'id' se refere ao identificador da proteína
        self.especie = especie #Onde 'especie' se refere a espécie da qual a proteína foi obtida (por exemplo, Homo sapiens)
        self.peso_molecular = peso_molecular #Onde 'peso_molecular' se refere ao peso em Da (Daltons)
        self.comprimento = comprimento #Onde 'comprimento' se refere ao comprimento da sequencia inserida, que pode variar de comprimento da sequencia de dna (se for DNA) ou da sequencia de aminoácidos
        self.sequence = ""

#Agora precisamos definir um método que consiga receber um arquivo FASTA e nos retorne a sequencia de DNA ou de Aminoácidos contida nele.
#Para isso, usamos dois @staticmethod que não necessitam de receber um argumento para funcionar, diferentemente dos outros métodos.
#A partir desses dois, conseguimos obter a sequencia que será traduzida de dentro do arquivo .fasta.

# O método estático 'main()' funciona como a porta de entrada do código. 
# Solicita o caminho de um arquivo FASTA, lê a sequência do arquivo, realiza a tradução da sequência lida, informa ao usuário informações da molécula, e por fim gera um arquivo de saída.
    @staticmethod
    def main():
        file_path = input("Digite o caminho do arquivo FASTA: ") # Pede o input do caminho do arquivo FASTA
        try:
            sequencias = Proteina.ler_arquivo_fasta(file_path) # Inicializa o método para ler o arquivo FASTA
        except FileNotFoundError:
            print("Arquivo não encontrado.") # Se por ventura o arquivo não for encontrado, de acordo como erro FileNotFound, aparece essa notificação.
            return
        except Exception as e:
            print("Erro ao ler o arquivo:", str(e))  # Se por ventura outro problema ocorrer, aparece essa notificação.
            return

        for biomolecule in sequencias:
            traducao = biomolecule.traduzir_sequencia() # definindo a variavel traducao como o método traduzir_sequencia()
            informacao_molecula = biomolecule.info_sequencia() # definindo a variavel informacao_molecula como o método info_sequencia()
            print(informacao_molecula) 
            print("Sequência traduzida:", traducao)
            biomolecule.gerar_arquivo_traducao(traducao) # Aqui ele printa na tela para o usuário as informações da molécula inserida, informa a sequencia traduzida e cria um novo arquivo contendo a sequencia traduzida.

# Agora o programa procede para o método estático 'ler_arquivo_fasta', que lê as sequências contidas no arquivo fasta, e retorna elas numa lista "sequencias".
# Além disso, retorna os objetos 'Proteina'.            
    @staticmethod
    def ler_arquivo_fasta(file_path):
        sequencias = [] # a lista vazia sequencias
        with open(file_path, 'r') as file: #abre o arquivo no modo leitura
            header = '' #header com as informações do cabeçalho
            sequence = '' #sequence com a informação da sequencia contida no arquivo
            for line in file:
                line = line.strip()
                if line.startswith('>'):
                    if header and sequence:
                        nome, especie = Proteina.extrair_informacoes_fasta(header) #correspondente ao id e a especie da molecula, que chama o método para extrair essas informações do cabeçalho
                        mw = Proteina.calculo_peso(sequence) #correspondente ao peso molecular de biomolecule.peso_molecular
                        tamanho = len(sequence) #correspondente ao comprimento da sequencia de biomolecule.comprimento
                        biomolecule = Proteina(nome, especie, mw, tamanho) #Objetos da classe proteína
                        biomolecule.sequence = sequence
                        sequencias.append(biomolecule) #junta as sequencias contidas em biomolecule.sequence, se existir mais de uma
                    header = line[1:]
                    sequence = ''
                else:
                    sequence += line

        if header and sequence:
            nome, especie = Proteina.extrair_informacoes_fasta(header)
            mw = Proteina.calculo_peso(sequence)
            tamanho = len(sequence)
            biomolecule = Proteina(nome, especie, mw, tamanho)
            biomolecule.sequence = sequence
            sequencias.append(biomolecule)

        return sequencias #retorna a lista sequencias

# O método estático extrair_informacoes_fasta recebe as inforamacoes do cabeçalho do arquivo fasta, e retorna as variaveis id_molecula e especie.
# Variáveis que são utilizadas para definir os objetos da classe Proteina, nome e especie.
    @staticmethod
    def extrair_informacoes_fasta(header):
        id_molecula = header.split()[0] #definindo uma forma de obtermos o código de ID da molecula
        fim_nome_molecula = header.find('[organism=') #definindo uma forma de obtermos o NOME da molecula
        especie = None 
        if fim_nome_molecula != -1:
            nome_molecula = header.split()[1]
            id_molecula = f"{id_molecula} - {nome_molecula}" #definindo que a informação id_molecula pega tanto o ID quanto o nome da molécula
            inicio_especie = fim_nome_molecula + len('[organism=') #definindo o inicio de especies
            fim_especie = header.index(']', inicio_especie) #definindo o fim de especies
            especie = header[inicio_especie:fim_especie] # definindo os limites do que é a espécie
        return id_molecula, especie #retorna essas duas variaveis

# O método estático calculo_peso recebe a sequencia como parametro, e pede um input pro usuario.
# Se esse input for DNA, o método calculo_dna é executado para a sequencia.
# Se esse input for aminoácidos, o método calculo_aminoacido é executado para a sequencia.
    @staticmethod
    def calculo_peso(sequence):
        informacao = input('Sua sequência é de DNA ou de aminoácidos? ') # pergunta uma informação ao usuário 
        if informacao.lower() == 'dna': #transforma o resultado do input em letra minuscula, e se o mesmo for igual a dna o programa prossegue
            peso_sequencia = Proteina.calculo_dna(sequence) # define que o método para calcular o peso vai ser de dna
        elif informacao.lower() == 'aminoácidos': #transforma o resultado do input em letra minuscula, e se o mesmo for igual a aminoácidos o programa prossegue
            peso_sequencia = Proteina.calculo_aminoacido(sequence) # define que o método para calcular o peso vai ser de aminoacidos
        else:
            raise ValueError('Tipo de sequência inválido.') #Se o usuário inserir algo que não seja nenhuma das duas opções, recebe esse erro.
        return peso_sequencia # Retorna a variavel peso_sequencia

# O programa prossegue para ou o método estático para calcular o peso molecular do DNA ou dos aminoácidos

# Método para Calculo dos Aminoácidos:
# Ele percorre cada elemento da sequência e soma os pesos moleculares correspondentes a cada aminoácido usando tabela de pesos moleculares pré-definida    
    @staticmethod
    def calculo_aminoacido(sequence):
        tabela_peso_aminoacidos = {
            'A': 89.09, 'R': 174.20, 'N': 132.12, 'D': 133.10, 'C': 121.16,
            'E': 147.13, 'Q': 146.15, 'G': 75.07, 'H': 155.16, 'I': 131.18,
            'L': 131.18, 'K': 146.19, 'M': 149.21, 'F': 165.19, 'P': 115.13,
            'S': 105.09, 'T': 119.12, 'W': 204.23, 'Y': 181.19, 'V': 117.15
        } # Definimos um dicionário com os pesos, em Daltons, correspondentes para cada aminoácido

        peso_molecular = 0.0 # Um número float
        for aminoacido in sequence:
            peso_molecular += tabela_peso_aminoacidos.get(aminoacido, 0.0) 
        peso_sequencia = round(peso_molecular, 2) # O valor resultante é arredondado para duas casas decimais e retornado
        return peso_sequencia #retorna a variavel que é utilizada como valor para o objeto mw, equivalente a biomolecule.peso_molecular

# Método para Calculo do DNA:
# Ele percorre cada elemento da sequência e soma os pesos moleculares correspondentes a cada base usando tabela de pesos moleculares pré-definida
    @staticmethod
    def calculo_dna(sequence):
        tabela_peso_bases = {'A': 331.2218, 'C': 307.1971, 'G': 347.2212, 'T': 322.2085}  #Definimos um dicionário com os pesos, em Daltons, correspondentes para cada base

        peso_molecular = 0.0 # Um número float
        for base in sequence:
            peso_molecular += tabela_peso_bases.get(base, 0.0)
        peso_sequencia = round(peso_molecular, 2) # O valor resultante é arredondado para duas casas decimais e retornado
        return peso_sequencia #retorna a variavel que é utilizada como valor para o objeto mw, equivalente a biomolecule.peso_molecular

# O método traduzir_sequencia chama os métodos traduzir_dna_aminoacidos ou traduzir_aminoacidos_dna para realizar a tradução da sequência.
# Se baseia em qual calculo do peso foi feito. 
    def traduzir_sequencia(self):
        if self.peso_molecular == Proteina.calculo_dna(self.sequence): #Se o calculo feito foi o do peso do DNA
            traducao = self.traduzir_dna_aminoacidos() #Ele chama o método para traduzir de DNA para aminoácido
        elif self.peso_molecular == Proteina.calculo_aminoacido(self.sequence): #Se o calculo feito foi o do peso dos aminoácidos
            traducao = self.traduzir_aminoacidos_dna() #Ele chama o método para traduzir de aminoacidos para DNA
        return traducao # retorna o resultado da tradução

# O método traduzir_dna_aminoacidos realiza a tradução de uma sequência de DNA para aminoácidos. Utilizando um dicionário de tradução pré-definidas para mapear os codons de DNA aos aminoácidos. 
# Os codons são percorridos na sequência original e a tradução é construída concatenando os resultados correspondentes.
    def traduzir_dna_aminoacidos(self):
        tabela_traducao = {
            'TTT': 'F', 'TTC': 'F', 'TTA': 'L', 'TTG': 'L',
            'TCT': 'S', 'TCC': 'S', 'TCA': 'S', 'TCG': 'S',
            'TAT': 'Y', 'TAC': 'Y', 'TAA': '*', 'TAG': '*',
            'TGT': 'C', 'TGC': 'C', 'TGA': '*', 'TGG': 'W',
            'CTT': 'L', 'CTC': 'L', 'CTA': 'L', 'CTG': 'L',
            'CCT': 'P', 'CCC': 'P', 'CCA': 'P', 'CCG': 'P',
            'CAT': 'H', 'CAC': 'H', 'CAA': 'Q', 'CAG': 'Q',
            'CGT': 'R', 'CGC': 'R', 'CGA': 'R', 'CGG': 'R',
            'ATT': 'I', 'ATC': 'I', 'ATA': 'I', 'ATG': 'M',
            'ACT': 'T', 'ACC': 'T', 'ACA': 'T', 'ACG': 'T',
            'AAT': 'N', 'AAC': 'N', 'AAA': 'K', 'AAG': 'K',
            'AGT': 'S', 'AGC': 'S', 'AGA': 'R', 'AGG': 'R',
            'GTT': 'V', 'GTC': 'V', 'GTA': 'V', 'GTG': 'V',
            'GCT': 'A', 'GCC': 'A', 'GCA': 'A', 'GCG': 'A',
            'GAT': 'D', 'GAC': 'D', 'GAA': 'E', 'GAG': 'E',
            'GGT': 'G', 'GGC': 'G', 'GGA': 'G', 'GGG': 'G',
        } # Construindo um dicionário com os Codons como chaves e a sigla correspondente aos aminoácidos como valores.

        traducao = ''
        codons = [self.sequence[i:i + 3] for i in range(0, len(self.sequence), 3)] #definindo como a leitura da sequencia será feita, no caso, de 3 em 3 posições, partindo da posição 0.
        for codon in codons:
            traducao += tabela_traducao.get(codon, '') # definindo que para cada codon teremos um valor correspondente aos aminoacidos, através do metodo get
        return traducao #retorna o resultado da tradução
    
# O método traduzir_aminoacidos_dna realiza a tradução de uma sequência de aminoácidos para DNA. Utilizando um dicionário de tradução pré-definidas para mapear os aminoácidos aos codons do DNA. 
# Os aminoácidos são percorridos na sequência original e a tradução é construída concatenando os resultados correspondentes.
    def traduzir_aminoacidos_dna(self):
        aminoacido_codon_table = {
            'F': ['TTT', 'TTC'], 'L': ['TTA', 'TTG', 'CTT', 'CTC', 'CTA', 'CTG'],
            'I': ['ATT', 'ATC', 'ATA'], 'M': ['ATG'],
            'V': ['GTT', 'GTC', 'GTA', 'GTG'], 'S': ['TCT', 'TCC', 'TCA', 'TCG', 'AGT', 'AGC'],
            'P': ['CCT', 'CCC', 'CCA', 'CCG'], 'T': ['ACT', 'ACC', 'ACA', 'ACG'],
            'A': ['GCT', 'GCC', 'GCA', 'GCG'], 'Y': ['TAT', 'TAC'],
            '*': ['TAA', 'TAG', 'TGA'],
            'H': ['CAT', 'CAC'], 'Q': ['CAA', 'CAG'],
            'N': ['AAT', 'AAC'], 'K': ['AAA', 'AAG'],
            'D': ['GAT', 'GAC'], 'E': ['GAA', 'GAG'],
            'C': ['TGT', 'TGC'], 'W': ['TGG'],
            'R': ['CGT', 'CGC', 'CGA', 'CGG', 'AGA', 'AGG'],
            'G': ['GGT', 'GGC', 'GGA', 'GGG'],
        } # Definindo um dicionário com os aminoácidos como chaves e os codons como valores.
        
        sequence = self.sequence.upper() # se por ventura a sequencia estivesse com letras minusculas, ela seria transposta para maiusculas
        aminoacidos = list(sequence)  # definindo a variavel aminoacidos

        codons = []
        for aminoacido in aminoacidos:
            codon = aminoacido_codon_table.get(aminoacido, []) # definindo que para cada aminoacido individual em aminoacidos teremos um valor correspondente aos codons, através do metodo get.
            codons.extend(codon)

        traducao = ''.join(codons) # Comando join para que os codons sejam unificados depois da tradução, e não apareçam separados no resultado.
        return traducao #retorna o resultado da tradução

# O método info_sequencia basicamente retorna ao usuário na tela, em formato de string formatada, algumas informações sobre a sequência, como o ID, a espécie, o peso molecular e o comprimento.
# Retorna a variável info
    def info_sequencia(self):
        info = f"O ID da sua molécula é: {self.id}\n" # ID
        info += f"A Espécie da sua molécula é: {self.especie}\n" # Espécie
        info += f"O Peso Molecular da sua molécula é de {self.peso_molecular} Da\n" # Peso molecular, calculado pelo método estático calculo_peso
        info += f"O Comprimento da sua molécula é de {self.comprimento} pb ou aminoácidos\n" # Comprimento, calculado por len(sequence)

        return info

# E por fim, para gerarmos um arquivo de texto com o resultado da tradução da senquencia do arquivo fasta, criamos o método gerar_arquivo_traduzido.
# O método funciona recebendo a tradução da sequência como parâmetro e gerando um arquivo de texto com o nome "id_traducao.txt", onde "id" é o ID da sequência.
    def gerar_arquivo_traducao(self, traducao):
        file_name = "arquivo_traducao.txt" # Definindo qual será o nome e o formato do arquivo, e posteriormente criando o arquivo, no mesmo diretório onde o arquivo fasta está presente
        with open(file_name, 'w') as file: # Abre o arquivo vazio no modo 'w' de escrita.
            file.write(f">{self.id}_traducao\n")  # Criamos um cabeçalho com o nome do arquivo, contendo o ID da sequencia
            file.write(f"{traducao}\n") # Inserimos a sequencia obtida através da tradução.
        print(f"Arquivo de tradução gerado: {file_name}") # Printa na tela que o arquivo foi criado com sucesso.

Proteina.main() #Chama o método, para que possamos testar a função.